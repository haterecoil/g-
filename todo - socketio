
/**
 * Socket IO 
 */
Serveur :
        stocker les parties en lignes
        recevoir une requête créer partie / rejoindre partie
        initialiser une partie (désigner le J1 , le J2)
        recevoir un coup
        évaluer sa validité
        renvoyer le coup aux deux joueurs
        dire à qui le tour

Client :
        initialiser une partie ONLINE !== OFFLINE
        attendre de savoir qui est J1/J2
        nextPlayer() différent selon OFF / ON

// Go_Online extend Go normal et a la propriété joueurId en plus ? 
// Go_Online inclut automatiquement le contrôlleur/modèle/vue online ?

// @self mentality of love

 I got a totally different approach, how I do it is to separate the sockets grouping them by aggregates and responsibility, lets say I have a socket file that only will have user interaction other for managing activity streams (in the case of a social network) or managing products, etc. look at them as you were looking at controllers in the MVC pattern.
 => rooms
 => game

rooms:createRoom
game:makeAMove
 
 BACKBONE? faut séparer les pages ! angular?
 ANGULAR? 
 http://stackoverflow.com/questions/20466129/how-to-organize-socket-handling-in-node-js-and-socket-io-app
 pareil que : http://stackoverflow.com/questions/26907441/node-js-socket-io-whats-the-best-way-to-organize-sockets

// Gérer ça propre parce que c'est tjrs la merde côté client
Lister évènements :
C S
  > (connect)
  < listRooms
  > createRoom
  > joinRoom
  
  > move 
  < validateMove
  < cancelMove

/**
 * Chaines
 */

Inclure les chaines dans l'objet intersection,
éviter de crawl les chaines à chaque fois
chaines = []
etc.


/**
 * 
 */

Rooms :


rooms = []




Events :

io.on.newRoom
	rooms.push new Room

io.on.disconnect
	if (rooms players < 1 )
		rooms.delete ( room )

io.on.listRooms
	io.send(rooms)

io.on.joinRoom
	rooms[room].addPlayer()




var Room = {
	players : { playerIds }
	id : { md5 of timestamp }
	protected : { bool }
	password :  { null || password}
}


Stocker les parties en cours :

1. Stateless
	envoyer le goban en serialized
	deserialized sur le server

	+ de network
	pas besoin de stocker les parties 

	Réception > init goban avec serializedGoban > validation

2. Stateful
	stocker les gobans sur le serveur // update une version locale du goban sur le serveur

	pas de network inutile. 
	Charge serveur =
	stock en mémoire d'une forme de goban ( pierres, positions, points de vie )

	Réception > trouver goban correspondant > validation 



